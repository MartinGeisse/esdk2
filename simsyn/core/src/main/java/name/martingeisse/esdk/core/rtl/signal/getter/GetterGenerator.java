package name.martingeisse.esdk.core.rtl.signal.getter;

import name.martingeisse.esdk.core.rtl.signal.RtlBitSignal;
import name.martingeisse.esdk.core.rtl.signal.RtlSignal;
import name.martingeisse.esdk.core.rtl.signal.RtlVectorSignal;
import name.martingeisse.esdk.core.util.vector.VectorValue;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.List;

/**
 * Each getter that is generated by this class is only used once since the code is highly specialized. So there is
 * no need to define useful names for its ultimate input signals or other data sources -- we just generate fields
 * with helper names, define and instantiate the class, then assign the data sources.
 */
class GetterGenerator {

    private static final String GET_BIT_SIGNATURE = "()Z";
    private static final String GET_VECTOR_SIGNATURE = "()L" + VectorValue.class.getName().replace('.', '/') + ";";

    private static int CLASS_COUNTER = 0;

    static RtlBitSignalGetter generate(RtlBitSignal signal) {
        return (RtlBitSignalGetter)generateInternal(RtlBitSignalGetter.class.getName().replace('.', '/'),
                GET_BIT_SIGNATURE, signal, Opcodes.IRETURN);
    }

    static RtlVectorSignalGetter generate(RtlVectorSignal signal) {
        return (RtlVectorSignalGetter)generateInternal(RtlVectorSignalGetter.class.getName().replace('.', '/'),
                GET_VECTOR_SIGNATURE, signal, Opcodes.ARETURN);
    }

    private static Object generateInternal(String superName, String descriptor, RtlSignal signal, int returnOpcode) {
        try {

            ClassNode classNode = new ClassNode();
            classNode.version = 52;
            classNode.name = "GeneratedSignalGetter_" + CLASS_COUNTER;
            classNode.superName = superName;
            classNode.access = Opcodes.ACC_PUBLIC;

            MethodNode constructorNode = new MethodNode();
            constructorNode.name = "<init>";
            constructorNode.desc = "()V";
            constructorNode.access = Opcodes.ACC_PUBLIC;
            constructorNode.visitCode();
            constructorNode.visitVarInsn(Opcodes.ALOAD, 0);
            constructorNode.visitMethodInsn(Opcodes.INVOKESPECIAL, superName.replace('.', '/'),
                    "<init>", "()V", false);
            constructorNode.visitInsn(Opcodes.RETURN);
            classNode.methods.add(constructorNode);

            MethodNode methodNode = new MethodNode();
            methodNode.name = "getValue";
            methodNode.desc = descriptor;
            methodNode.access = Opcodes.ACC_PUBLIC;

            GetterGenerator generator = new GetterGenerator(classNode, methodNode);
            methodNode.visitCode();
            generator.renderSignal(signal);
            methodNode.visitInsn(returnOpcode);
            classNode.methods.add(methodNode);

            CLASS_COUNTER++;
            Object instance = GeneratedClassLoader.INSTANCE.defineClass(classNode).newInstance();
            generator.initializeFields(instance);
            return instance;

        } catch (Exception e) {
            throw new RuntimeException("could not generate signal getter", e);
        }
    }

    private final ClassNode classNode;
    private final MethodNode methodNode;
    private final List<Object> references = new ArrayList<>();

    GetterGenerator(ClassNode classNode, MethodNode methodNode) {
        this.classNode = classNode;
        this.methodNode = methodNode;
    }

    void renderSignal(RtlSignal signal) {
        renderReference(signal);
        if (signal instanceof RtlBitSignal) {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, RtlBitSignal.class.getName().replace('.', '/'),
                    "getValue", GET_BIT_SIGNATURE, true);
        } else {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, RtlVectorSignal.class.getName().replace('.', '/'),
                    "getValue", GET_VECTOR_SIGNATURE, true);
        }
    }

    void renderReference(Object reference) {
        String name = "reference" + references.size();
        String descriptor = "Ljava/lang/Object;";
        classNode.visitField(Opcodes.ACC_PUBLIC, name, descriptor, null, null);
        methodNode.visitVarInsn(Opcodes.ALOAD, 0);
        methodNode.visitFieldInsn(Opcodes.GETFIELD, classNode.name, name, descriptor);
        references.add(reference);
    }

    void initializeFields(Object instance) throws Exception {
        Class<?> theClass = instance.getClass();
        for (int i = 0; i < references.size(); i++) {
            Object reference = references.get(i);
            theClass.getField("reference" + i).set(instance, reference);
        }
    }

}
