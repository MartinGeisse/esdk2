package name.martingeisse.esdk.core.rtl.signal.getter;

import name.martingeisse.esdk.core.rtl.block.RtlProceduralBitRegister;
import name.martingeisse.esdk.core.rtl.signal.*;
import name.martingeisse.esdk.core.rtl.signal.connector.RtlSignalConnector;
import name.martingeisse.esdk.core.util.vector.VectorValue;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.List;

/**
 * Each getter that is generated by this class is only used once since the code is highly specialized. So there is
 * no need to define useful names for its ultimate input signals or other data sources -- we just generate fields
 * with helper names, define and instantiate the class, then assign the data sources.
 */
class GetterGenerator {

    private static final String GET_BIT_SIGNATURE = "()Z";
    private static final String GET_VECTOR_SIGNATURE = "()L" + internal(VectorValue.class) + ";";

    private static int CLASS_COUNTER = 0;

    static RtlBitSignalGetter generate(RtlBitSignal signal) {
        return (RtlBitSignalGetter)generateInternal(RtlBitSignalGetter.class,
                GET_BIT_SIGNATURE, signal, Opcodes.IRETURN);
    }

    static RtlVectorSignalGetter generate(RtlVectorSignal signal) {
        return (RtlVectorSignalGetter)generateInternal(RtlVectorSignalGetter.class,
                GET_VECTOR_SIGNATURE, signal, Opcodes.ARETURN);
    }

    private static final String internal(Class<?> c) {
        return c.getName().replace('.', '/');
    }

    private static Object generateInternal(Class<?> superClass, String descriptor, RtlSignal signal, int returnOpcode) {
        try {

            ClassNode classNode = new ClassNode();
            classNode.version = 52;
            classNode.name = "GeneratedSignalGetter_" + CLASS_COUNTER;
            classNode.superName = internal(superClass);
            classNode.access = Opcodes.ACC_PUBLIC;

            MethodNode constructorNode = new MethodNode();
            constructorNode.name = "<init>";
            constructorNode.desc = "()V";
            constructorNode.access = Opcodes.ACC_PUBLIC;
            constructorNode.visitCode();
            constructorNode.visitVarInsn(Opcodes.ALOAD, 0);
            constructorNode.visitMethodInsn(Opcodes.INVOKESPECIAL, internal(superClass), "<init>", "()V", false);
            constructorNode.visitInsn(Opcodes.RETURN);
            classNode.methods.add(constructorNode);

            MethodNode methodNode = new MethodNode();
            methodNode.name = "getValue";
            methodNode.desc = descriptor;
            methodNode.access = Opcodes.ACC_PUBLIC;

            GetterGenerator generator = new GetterGenerator(classNode, methodNode);
            methodNode.visitCode();
            generator.renderSignal(signal);
            methodNode.visitInsn(returnOpcode);
            classNode.methods.add(methodNode);

            CLASS_COUNTER++;
            Object instance = GeneratedClassLoader.INSTANCE.defineClass(classNode).newInstance();
            generator.initializeFields(instance);
            return instance;

        } catch (Exception e) {
            throw new RuntimeException("could not generate signal getter", e);
        }
    }

    private final ClassNode classNode;
    private final MethodNode methodNode;
    private final List<Object> references = new ArrayList<>();

    GetterGenerator(ClassNode classNode, MethodNode methodNode) {
        this.classNode = classNode;
        this.methodNode = methodNode;
    }

    void renderSignal(RtlSignal signal) {

        // handle connectors
        if (signal instanceof RtlSignalConnector) {
            renderSignal(((RtlSignalConnector) signal).getConnected());
            return;
        }

        // handle procedural registers (avoiding the interface method call)
        if (signal instanceof RtlProceduralBitRegister) {
            renderReference(signal);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(RtlProceduralBitRegister.class),
                    "getValue", "()Z", false);
            return;
        }

        // handle bit operations
        if (signal instanceof RtlBitNotOperation) {
            renderSignal(((RtlBitNotOperation) signal).getOperand());
            Label label1 = new Label();
            Label label2 = new Label();
            methodNode.visitJumpInsn(Opcodes.IFNE, label1);
            methodNode.visitInsn(Opcodes.ICONST_1);
            methodNode.visitJumpInsn(Opcodes.GOTO, label2);
            methodNode.visitLabel(label1);
            methodNode.visitInsn(Opcodes.ICONST_0);
            methodNode.visitLabel(label2);
            return;
        }

        // fallback: call .getValue()
        renderReference(signal);
        if (signal instanceof RtlBitSignal) {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, internal(RtlBitSignal.class),
                    "getValue", GET_BIT_SIGNATURE, true);
        } else {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, internal(RtlVectorSignal.class),
                    "getValue", GET_VECTOR_SIGNATURE, true);
        }

    }

    void renderReference(Object reference) {
        String name = "reference" + references.size();
        String descriptor = "L" + internal(reference.getClass()) + ";";
        classNode.visitField(Opcodes.ACC_PUBLIC, name, descriptor, null, null);
        methodNode.visitVarInsn(Opcodes.ALOAD, 0);
        methodNode.visitFieldInsn(Opcodes.GETFIELD, classNode.name, name, descriptor);
        references.add(reference);
    }

    void initializeFields(Object instance) throws Exception {
        Class<?> theClass = instance.getClass();
        for (int i = 0; i < references.size(); i++) {
            Object reference = references.get(i);
            theClass.getField("reference" + i).set(instance, reference);
        }
    }

}
