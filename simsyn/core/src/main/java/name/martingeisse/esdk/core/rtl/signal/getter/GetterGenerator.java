package name.martingeisse.esdk.core.rtl.signal.getter;

import name.martingeisse.esdk.core.rtl.block.RtlProceduralBitRegister;
import name.martingeisse.esdk.core.rtl.block.RtlProceduralMemoryIndexSelection;
import name.martingeisse.esdk.core.rtl.block.RtlProceduralVectorRegister;
import name.martingeisse.esdk.core.rtl.signal.*;
import name.martingeisse.esdk.core.rtl.signal.connector.RtlSignalConnector;
import name.martingeisse.esdk.core.util.Matrix;
import name.martingeisse.esdk.core.util.vector.VectorValue;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.List;

/**
 * Each getter that is generated by this class is only used once since the code is highly specialized. So there is
 * no need to define useful names for its ultimate input signals or other data sources -- we just generate fields
 * with helper names, define and instantiate the class, then assign the data sources.
 */
class GetterGenerator {

    private static final String GET_BIT_SIGNATURE = "()Z";
    private static final String GET_VECTOR_SIGNATURE = "()L" + internal(VectorValue.class) + ";";

    private static int CLASS_COUNTER = 0;

    static RtlBitSignalGetter generate(RtlBitSignal signal) {
        return (RtlBitSignalGetter)generateInternal(RtlBitSignalGetter.class,
                GET_BIT_SIGNATURE, signal, Opcodes.IRETURN);
    }

    static RtlVectorSignalGetter generate(RtlVectorSignal signal) {
        return (RtlVectorSignalGetter)generateInternal(RtlVectorSignalGetter.class,
                GET_VECTOR_SIGNATURE, signal, Opcodes.ARETURN);
    }

    private static final String internal(Class<?> c) {
        return c.getName().replace('.', '/');
    }

    private static Object generateInternal(Class<?> superClass, String descriptor, RtlSignal signal, int returnOpcode) {
        try {

            ClassNode classNode = new ClassNode();
            classNode.version = 52;
            classNode.name = "GeneratedSignalGetter_" + CLASS_COUNTER;
            classNode.superName = internal(superClass);
            classNode.access = Opcodes.ACC_PUBLIC;

            MethodNode constructorNode = new MethodNode();
            constructorNode.name = "<init>";
            constructorNode.desc = "()V";
            constructorNode.access = Opcodes.ACC_PUBLIC;
            constructorNode.visitCode();
            constructorNode.visitVarInsn(Opcodes.ALOAD, 0);
            constructorNode.visitMethodInsn(Opcodes.INVOKESPECIAL, internal(superClass), "<init>", "()V", false);
            constructorNode.visitInsn(Opcodes.RETURN);
            classNode.methods.add(constructorNode);

            MethodNode methodNode = new MethodNode();
            methodNode.name = "getValue";
            methodNode.desc = descriptor;
            methodNode.access = Opcodes.ACC_PUBLIC;

            GetterGenerator generator = new GetterGenerator(classNode, methodNode);
            methodNode.visitCode();
            generator.renderSignal(signal);
            methodNode.visitInsn(returnOpcode);
            classNode.methods.add(methodNode);

            CLASS_COUNTER++;
            Object instance = GeneratedClassLoader.INSTANCE.defineClass(classNode).newInstance();
            generator.initializeFields(instance);
            return instance;

        } catch (Exception e) {
            throw new RuntimeException("could not generate signal getter", e);
        }
    }

    private final ClassNode classNode;
    private final MethodNode methodNode;
    private final List<Object> references = new ArrayList<>();

    GetterGenerator(ClassNode classNode, MethodNode methodNode) {
        this.classNode = classNode;
        this.methodNode = methodNode;
    }

    void renderSignal(RtlSignal signal) {

        // handle connectors
        if (signal instanceof RtlSignalConnector) {
            renderSignal(((RtlSignalConnector) signal).getConnected());
            return;
        }

        // handle procedural registers (avoiding the interface method call)
        if (signal instanceof RtlProceduralBitRegister) {
            renderReference(signal);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(RtlProceduralBitRegister.class),
                    "getValue", GET_BIT_SIGNATURE, false);
            return;
        }
        if (signal instanceof RtlProceduralVectorRegister) {
            renderReference(signal);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(RtlProceduralVectorRegister.class),
                    "getValue", GET_VECTOR_SIGNATURE, false);
            return;
        }

        // handle bit operations
        if (signal instanceof RtlBitNotOperation) {
            renderSignal(((RtlBitNotOperation) signal).getOperand());
            renderBitSwitch(() -> methodNode.visitInsn(Opcodes.ICONST_1), () -> methodNode.visitInsn(Opcodes.ICONST_0));
            return;
        }
        if (signal instanceof RtlBitOperation) {
            RtlBitOperation operation = (RtlBitOperation)signal;
            renderSignal(operation.getLeftOperand());
            switch (operation.getOperator()) {

                case AND:
                    renderBitSwitch(() -> methodNode.visitInsn(Opcodes.ICONST_0),
                            () -> renderSignal(operation.getRightOperand()));
                    break;

                case OR:
                    renderBitSwitch(() -> renderSignal(operation.getRightOperand()),
                            () -> methodNode.visitInsn(Opcodes.ICONST_1));
                    break;

                case XOR:
                    renderSignal(operation.getRightOperand());
                    renderIfTrue(this::renderNot);
                    break;

                case XNOR:
                    renderSignal(operation.getRightOperand());
                    renderIfFalse(this::renderNot);
                    break;

                default:
                    throw new RuntimeException("unknown RtlBitOperation.Operator: " + operation.getOperator());

            }
            return;
        }

        // handle vector operations
        if (signal instanceof RtlVectorOperation) {
            RtlVectorOperation operation = (RtlVectorOperation)signal;
            renderSignal(operation.getLeftOperand());
            renderSignal(operation.getRightOperand());
            String operationMethodName;
            switch (operation.getOperator()) {

                case ADD:
                    operationMethodName = "add";
                    break;

                case SUBTRACT:
                    operationMethodName = "subtract";
                    break;

                case MULTIPLY:
                    operationMethodName = "multiply";
                    break;

                case AND:
                    operationMethodName = "and";
                    break;

                case OR:
                    operationMethodName = "or";
                    break;

                case XOR:
                    operationMethodName = "xor";
                    break;

                default:
                    throw new RuntimeException("unknown RtlVectorOperation.Operator: " + operation.getOperator());

            }
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), operationMethodName,
                    "(L" + internal(VectorValue.class) + ";)L" + internal(VectorValue.class) + ";", false);
            return;
        }

        // handle vector comparison
        if (signal instanceof RtlVectorComparison) {
            RtlVectorComparison comparison = (RtlVectorComparison)signal;
            renderSignal(comparison.getLeftOperand());
            renderSignal(comparison.getRightOperand());
            RtlVectorComparison.Operator operator = comparison.getOperator();
            if (operator == RtlVectorComparison.Operator.EQUAL || operator == RtlVectorComparison.Operator.NOT_EQUAL) {
                methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "equals",
                        "(Ljava/lang/Object;)Z", false);
                if (operator == RtlVectorComparison.Operator.NOT_EQUAL) {
                    renderNot();
                }
            } else {
                methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "compareUnsigned",
                        "(L" + internal(VectorValue.class) + ";)I", false);
                switch (operator) {
                    case UNSIGNED_LESS_THAN:
                        renderBitSwitchToBoolean(Opcodes.IFLT);
                        break;
                    case UNSIGNED_LESS_THAN_OR_EQUAL:
                        renderBitSwitchToBoolean(Opcodes.IFLE);
                        break;
                    case UNSIGNED_GREATER_THAN:
                        renderBitSwitchToBoolean(Opcodes.IFGT);
                        break;
                    case UNSIGNED_GREATER_THAN_OR_EQUAL:
                        renderBitSwitchToBoolean(Opcodes.IFGE);
                        break;
                    default:
                        throw new RuntimeException("unknown RtlVectorComparison.Operator: " + comparison.getOperator());
                }
            }
            return;
        }

        // handle conditional operations
        if (signal instanceof RtlConditionalOperation) {
            RtlConditionalOperation conditional = (RtlConditionalOperation)signal;
            renderSignal(conditional.getCondition());
            renderBitSwitch(() -> renderSignal(conditional.getOnFalse()), () -> renderSignal(conditional.getOnTrue()));
            return;
        }

        // handle concatenation
        if (signal instanceof RtlConcatenation) {
            renderReference(VectorValue.of(0, 0));
            for (RtlSignal elementSignal : ((RtlConcatenation) signal).getSignals()) {
                renderSignal(elementSignal);
                if (elementSignal instanceof RtlBitSignal) {
                    methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "concat",
                            "(Z)L" + internal(VectorValue.class) + ";", false);
                } else if (elementSignal instanceof RtlVectorSignal) {
                    methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "concat",
                            "(L" + internal(VectorValue.class) + ";)L" + internal(VectorValue.class) + ";", false);
                } else {
                    throw new RuntimeException("invalid signal: " + elementSignal);
                }
            }
            return;
        }

        // handle switch/case signals
        if (signal instanceof RtlSwitchSignal<?>) {
            RtlSwitchSignal<?> switchSignal = (RtlSwitchSignal<?>)signal;

            // labels
            Label[] caseMatchedLabels = new Label[switchSignal.getCases().size()];
            for (int i = 0; i < caseMatchedLabels.length; i++) {
                caseMatchedLabels[i] = new Label();
            }
            Label finishLabel = new Label();

            // branching
            {
                renderSignal(switchSignal.getSelector());
                int caseIndex = 0;
                for (RtlSwitchSignal.Case<?> aCase : switchSignal.getCases()) {
                    for (VectorValue selectorValue : aCase.getSelectorValues()) {
                        methodNode.visitInsn(Opcodes.DUP);
                        renderReference(selectorValue);
                        methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "equals",
                                "(Ljava/lang/Object;)Z", false);
                        methodNode.visitJumpInsn(Opcodes.IFNE, caseMatchedLabels[caseIndex]);
                    }
                    caseIndex++;
                }
                methodNode.visitInsn(Opcodes.POP);
                if (switchSignal.getDefaultSignal() == null) {
                    methodNode.visitTypeInsn(Opcodes.NEW, internal(RuntimeException.class));
                    methodNode.visitInsn(Opcodes.DUP);
                    methodNode.visitMethodInsn(Opcodes.INVOKESPECIAL, internal(RuntimeException.class), "<init>",
                            "()V", false);
                    methodNode.visitInsn(Opcodes.ATHROW);
                } else {
                    renderSignal(switchSignal.getDefaultSignal());
                    methodNode.visitJumpInsn(Opcodes.GOTO, finishLabel);
                }
            }

            // results
            {
                int caseIndex = 0;
                for (RtlSwitchSignal.Case<?> aCase : switchSignal.getCases()) {
                    methodNode.visitLabel(caseMatchedLabels[caseIndex]);
                    methodNode.visitInsn(Opcodes.POP);
                    renderSignal(aCase.getBranch());
                    methodNode.visitJumpInsn(Opcodes.GOTO, finishLabel);
                    caseIndex++;
                }
            }
            methodNode.visitLabel(finishLabel);
            return;
        }

        // selections (bit from vector, vector from vector, vector from matrix)
        if (signal instanceof RtlConstantIndexSelection) {
            RtlConstantIndexSelection selection = (RtlConstantIndexSelection)signal;
            renderSignal(selection.getContainerSignal());
            push(selection.getIndex());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "select", "(I)Z", false);
            return;
        }
        if (signal instanceof RtlIndexSelection) {
            RtlIndexSelection selection = (RtlIndexSelection)signal;
            renderSignal(selection.getContainerSignal());
            renderSignal(selection.getIndexSignal());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "getAsUnsignedInt",
                    "()I", false);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "select", "(I)Z", false);
            return;
        }
        if (signal instanceof RtlRangeSelection) {
            RtlRangeSelection selection = (RtlRangeSelection)signal;
            renderSignal(selection.getContainerSignal());
            push(selection.getFrom());
            push(selection.getTo());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "select",
                    "(II)L" + internal(VectorValue.class) + ";", false);
            return;
        }
        if (signal instanceof RtlProceduralMemoryIndexSelection) {
            RtlProceduralMemoryIndexSelection selection = (RtlProceduralMemoryIndexSelection)signal;
            renderReference(selection.getMemory().getMatrix());
            renderSignal(selection.getIndexSignal());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(VectorValue.class), "getAsUnsignedInt",
                    "()I", false);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Matrix.class), "getRow",
                    "(I)L" + internal(VectorValue.class) + ";", false);
            return;
        }

        // fallback: call .getValue()
        renderReference(signal);
        if (signal instanceof RtlBitSignal) {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, internal(RtlBitSignal.class),
                    "getValue", GET_BIT_SIGNATURE, true);
        } else {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, internal(RtlVectorSignal.class),
                    "getValue", GET_VECTOR_SIGNATURE, true);
        }

    }

    void renderReference(Object reference) {
        String name = "reference" + references.size();
        String descriptor = "L" + internal(reference.getClass()) + ";";
        classNode.visitField(Opcodes.ACC_PUBLIC, name, descriptor, null, null);
        methodNode.visitVarInsn(Opcodes.ALOAD, 0);
        methodNode.visitFieldInsn(Opcodes.GETFIELD, classNode.name, name, descriptor);
        references.add(reference);
    }

    // computes the logical NOT of the top-of-stack
    void renderNot() {
        renderBitSwitch(() -> methodNode.visitInsn(Opcodes.ICONST_1), () -> methodNode.visitInsn(Opcodes.ICONST_0));
    }

    void renderBitSwitch(int branchingOpcode, Runnable falseCase, Runnable trueCase) {
        Label label1 = new Label();
        Label label2 = new Label();
        methodNode.visitJumpInsn(branchingOpcode, label1);
        falseCase.run();
        methodNode.visitJumpInsn(Opcodes.GOTO, label2);
        methodNode.visitLabel(label1);
        trueCase.run();
        methodNode.visitLabel(label2);
    }

    void renderBitSwitch(Runnable falseCase, Runnable trueCase) {
        renderBitSwitch(Opcodes.IFNE, falseCase, trueCase);
    }

    void renderBitSwitchToBoolean(int branchingOpcode) {
        renderBitSwitch(branchingOpcode, () -> methodNode.visitInsn(Opcodes.ICONST_0),
                () -> methodNode.visitInsn(Opcodes.ICONST_1));
    }

    // pops the top-of-stack and executes a piece of code if it is true
    void renderIfTrue(Runnable trueCase) {
        Label label = new Label();
        methodNode.visitJumpInsn(Opcodes.IFEQ, label);
        trueCase.run();
        methodNode.visitLabel(label);
    }

    // pops the top-of-stack and executes a piece of code if it is false
    void renderIfFalse(Runnable falseCase) {
        Label label = new Label();
        methodNode.visitJumpInsn(Opcodes.IFNE, label);
        falseCase.run();
        methodNode.visitLabel(label);
    }

    void push(int value) {
        switch (value) {

            case -1:
                methodNode.visitInsn(Opcodes.ICONST_M1);
                return;

            case 0:
                methodNode.visitInsn(Opcodes.ICONST_0);
                return;

            case 1:
                methodNode.visitInsn(Opcodes.ICONST_1);
                return;

            case 2:
                methodNode.visitInsn(Opcodes.ICONST_2);
                return;

            case 3:
                methodNode.visitInsn(Opcodes.ICONST_3);
                return;

            case 4:
                methodNode.visitInsn(Opcodes.ICONST_4);
                return;

            case 5:
                methodNode.visitInsn(Opcodes.ICONST_5);
                return;

        }
        if (value == (byte)value) {
            methodNode.visitIntInsn(Opcodes.BIPUSH, value);
            return;
        }
        if (value == (short)value) {
            methodNode.visitIntInsn(Opcodes.SIPUSH, value);
            return;
        }
        methodNode.visitLdcInsn(value);
    }

    void initializeFields(Object instance) throws Exception {
        Class<?> theClass = instance.getClass();
        for (int i = 0; i < references.size(); i++) {
            Object reference = references.get(i);
            theClass.getField("reference" + i).set(instance, reference);
        }
    }

}
