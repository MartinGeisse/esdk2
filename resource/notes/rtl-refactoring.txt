
RtlSignal.printVerilogImplementationExpression()
    default implementation that throws a SynthesisNotSupportedException
    -> allows lambda implementations. Those are not RtlItems. Consequences?
        cannot checkSameRealm()
        cannot obtain design from it
            -> not a real problem. Also, not everything must be an item if it doesn't need simulation callbacks.

Follow-up question: How important is checkSameRealm()? Or that all RTL items have a realm?
    Not for convenience. ESDK checks the realm but doesn't propagate it, so you still have to specify it everywhere.
    same-design check is not needed (multiple designs are simply disallowed). Not everything must be an item,
        only those objects that want to receive callbacks.
    RtlRealm comment already questions whether RtlRealm is useful.
    RtlRealm.getItems() and .getPins() can simply ask the design for all items and cast them. This is only used
        during synthesis anyway, so there isn't a huge performance problem. (Even if there is, this can be handled
        by Design in an abstract way).
    .onClockEdge() could use the design. The clock network can fetch all clocked items at startup so performance
        does not suffer. (The items of a design must not change at runtime).

--> provides minimal advantage. Real own HDL would be better. Does not have to have generics / templating support,
but should rather integrate nicely with ESDK.

    interface MyItf {
    }

    interface type IType {
    }

    interface IType MyItf2;

    module name.martingeisse.esdk.library.vga.Timer vgaTimer;

    No bidirectional / high-Z support. All that must be done in ESDK, not HDL.

    (Can have a single unnamed interface, or one or more named interface -- if any interface is named, all must be
    named. v1: unnamed only). IDE action to generate a convenience class.
