
carry as implicit upper framebuffer address bit is super annoying. It would be better to make that bit loadable,
probably load *from* the carry flag, but then stay independent. That would be the second "special" instruction
besides "sb".

Selecting the bank by a stateful flag isn't nice. Just for clearing the screen, I'd like to use a pointer that gets
incremented, but the pointer would be in bank 0 and the framebuffer in bank 1. So a bank bit in the instruction would
be better (Note: The address (immediate or Y) has 8 bits). This is actually easy for store instructions because I have
lots of bits left, but for loading it is a problem since no bits are left. OTOH let's assume that 3 opcode bits get
decoded instead of 2. Then 4 of 8 instructions are "loading" instructions (x/y destination; bank bit) and 2 are stores
(bank bit); 1 is branch/jump and one is special (if no other special instructions are needed, that would directly
load I/O address bit 9 from the carry flag). So the opcode map would be:

0dbaofff - operation(destination, bank, address source, operand source, function)
10ba.... - store(bank, address source)
110..... - branch / jump
111..... - special
-->
    Note: could separate read-bank from write-bank and use a stateful flag for reading (reading from bank 1 is rarely
    used) and instruction bit for writing. I'll do that when I'm out of bits for the "reading" instructions, such as
    if three function bits are too few.


Idea: I might use y for data and x for the address when storing to the framebuffer, simply by exchanging the wires for
address and data on the GPU board. This might make the code much simpler since for GFX I'm mostly storing the same value
over and over to different computed addresses. Being a separate bank, this should be easy without side effects.

