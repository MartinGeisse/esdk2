module name.martingeisse.esdk.riscv.rtl.ram.RamController;

interface {

    // system signals
    in clock clk0;
    in clock clk90;
    in clock clk180;
    in clock clk270;
    in bit reset;

    // Wishbone interface
    in vector[24] busWordAddress;
    in bit busEnable, busWrite;
    in vector[32] busWriteData;
    in vector[4] busWriteMask;
    out vector[32] busReadData;
    out bit busAcknowledge;

}

// interface to SDRAM
name.martingeisse.esdk.riscv.rtl.ram.SdramConnector sdram;
do (*) {
    sdram.clk0 = clk0;
    sdram.clk90 = clk90;
    sdram.clk180 = clk180;
    sdram.clk270 = clk270;
}

// timing
constant vector[5] WAIT_TIME = 5d5;
constant vector[15] INIT_WAIT = 15h3000;
constant vector[15] INIT_CLK_EN_WAIT = 15h10;
constant vector[6] WAIT_CMD_MAX = 6b100000;
constant vector[6] REFRESH_WAIT = WAIT_CMD_MAX - 6d7;
constant vector[6] ACCESS_WAIT = WAIT_CMD_MAX - 6d1;
constant vector[6] CAS_WAIT = WAIT_CMD_MAX - 6d3;
constant vector[10] AVG_REFRESH_DUR = 10d700;

// main state machine
constant vector[6] SD_IDLE = 0;
constant vector[6] SD_INIT = 1;
constant vector[6] SD_INIT_WAIT = 2;
constant vector[6] SD_PRECHG_ALL = 3;
constant vector[6] SD_PRECHG_ALL1 = 4;
constant vector[6] SD_AUTO_REF = 5;
constant vector[6] SD_AUTO_REF1 = 6;
constant vector[6] SD_AUTO_REF_ACK = 7;
constant vector[6] SD_LD_MODE = 8;
constant vector[6] SD_LD_MODE1 = 9;
constant vector[6] SD_RD_START = 10;
constant vector[6] SD_RD_COL = 11;
constant vector[6] SD_RD_CAS_WAIT = 12;
constant vector[6] SD_RD_LATCH = 13;
constant vector[6] SD_RD_LATCH1 = 14;
constant vector[6] SD_RD_DONE = 15;
constant vector[6] SD_WR_START = 16;
constant vector[6] SD_WR_COL = 17;
constant vector[6] SD_WR_CAS_WAIT = 18;
constant vector[6] SD_WR_LATCH = 19;
constant vector[6] SD_WR_LATCH1 = 20;
constant vector[6] SD_WR_DONE = 21;
constant vector[6] SD_RD_DONE_1 = 22;
constant vector[6] SD_WR_DONE_1 = 23;

// initialization state machine
constant vector[4] SI_START = 0;
constant vector[4] SI_PRECHG = 1;
constant vector[4] SI_LOAD_EX_MODE = 2;
constant vector[4] SI_LOAD_MODE = 3;
constant vector[4] SI_LOAD_MODE2 = 4;
constant vector[4] SI_PRECHG2 = 5;
constant vector[4] SI_AUTO_REF = 6;
constant vector[4] SI_AUTO_REF2 = 7;
constant vector[4] SI_DONE = 8;

// SDRAM output registers for the main and init state machine
register bit sdramRegisterCKE;
register bit sdramRegisterCS;
register vector[2] sdramRegisterBA;
register vector[13] sdramRegisterA;
register bit sdramRegisterRAS;
register bit sdramRegisterCAS;
register bit sdramRegisterWE;
do (*) {
    sdram.sdramCKE = sdramRegisterCKE;
    sdram.sdramCS = sdramRegisterCS;
    sdram.sdramBA = sdramRegisterBA;
    sdram.sdramA = sdramRegisterA;
    sdram.sdramRAS = sdramRegisterRAS;
    sdram.sdramCAS = sdramRegisterCAS;
    sdram.sdramWE = sdramRegisterWE;
}

// Wishbone output registers for the main and init state machine
register bit busRegisterAcknowledge;
register vector[32] busRegisterReadData;
do (*) {
    busAcknowledge = busRegisterAcknowledge;
    busReadData = busRegisterReadData;
}

// output registers for DDR signals
register bit ddrRegisterDataStrobeEnable;
register bit ddrRegisterDataStrobe;
register bit ddrRegisterDataOutEnable;
register vector[32] ddrRegisterDataOut;
register vector[4] ddrRegisterDataOutMask;
do (*) {
    sdram.ddrInterfaceDataStrobeEnable = ddrRegisterDataStrobeEnable;
    sdram.ddrInterfaceDataStrobe = ddrRegisterDataStrobe;
    sdram.ddrInterfaceDataOutEnable = ddrRegisterDataOutEnable;
    sdram.ddrInterfaceDataOut = ddrRegisterDataOut;
    sdram.ddrInterfaceDataOutMask = ddrRegisterDataOutMask;
}

// DDR data sampling
register vector[32] ddrRegisterDataIn;
do (clk180) {
    ddrRegisterDataIn = sdram.ddrInterfaceDataIn;
}

// main and init state machines
register bit refreshAcknowledge;
register vector[6] sd_state;
register vector[4] init_state;
register vector[6] wait_count;
register vector[15] init_wait_count;
register vector[13] mode_reg;

do (clk0) {
    if (reset) {
        sd_state = SD_INIT;
        init_state = SI_START;
    } else {
        wait_count = wait_count + 6d1;
        switch (sd_state) {

            // Initialize, wait until INIT_WAIT
            case SD_INIT:
                switch (init_state) {
                    case SI_START:
                        sd_state = SD_INIT_WAIT;
                        init_state = SI_PRECHG;
                        sdramRegisterRAS = 1;
                        sdramRegisterCAS = 1;
                        sdramRegisterWE = 1;
                        sdramRegisterCS = 1;
                        sdramRegisterCKE = 0;
                        init_wait_count = 0;

                    case SI_PRECHG:
                        sd_state = SD_PRECHG_ALL;
                        init_state = SI_LOAD_EX_MODE;

                    case SI_LOAD_EX_MODE:
                        // Normal operation
                        mode_reg = 13b0000000000000;
                        sdramRegisterBA = 2b01;
                        sd_state = SD_LD_MODE;
                        init_state = SI_LOAD_MODE;

                    case SI_LOAD_MODE:
                        // CAS = 2, Reset DLL, Burst = 2, sequential
                        mode_reg = 6b000010 _ 3b010 _ 1b0 _ 3b001;
                        sdramRegisterBA = 2b00;
                        sd_state = SD_LD_MODE;
                        init_state = SI_LOAD_MODE2;

                    case SI_LOAD_MODE2:
                        // CAS = 2, NO Reset DLL, Burst = 2, sequential
                        mode_reg = 6b000000 _ 3b010 _ 1b0 _ 3b001;
                        sdramRegisterBA = 2b00;
                        sd_state = SD_LD_MODE;
                        init_state = SI_PRECHG2;

                    case SI_PRECHG2:
                        sd_state = SD_PRECHG_ALL;
                        init_state = SI_AUTO_REF;

                    case SI_AUTO_REF:
                        sd_state = SD_AUTO_REF;
                        init_state = SI_AUTO_REF2;

                    case SI_AUTO_REF2:
                        sd_state = SD_AUTO_REF;
                        init_state = SI_DONE;

                    case SI_DONE:
                        init_state = SI_DONE;
                        sd_state = SD_IDLE;

                    default:
                        init_state = SI_START;

                }


            // ** Waiting for SDRAM waking up *****************************
            case SD_INIT_WAIT:
                init_wait_count = init_wait_count + 15d1;
                if (init_wait_count == INIT_WAIT) {
                    sd_state = SD_INIT;
                }
                if (init_wait_count == INIT_CLK_EN_WAIT) {
                    sdramRegisterCKE = 1;
                }

            // ** Precharge command ***************************************
            case SD_PRECHG_ALL:
                sd_state = SD_PRECHG_ALL1;
                sdramRegisterRAS = 0;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 0;
                sdramRegisterCS = 0;
                sdramRegisterA[10] = 1;				// Command for precharge all

            case SD_PRECHG_ALL1:
                sdramRegisterCS = 1;
                sdramRegisterRAS = 1;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;
                sd_state = SD_IDLE;			// Precharge takes 15nS before next command

            // ** Load mode register **************************************
            case SD_LD_MODE:
                sd_state = SD_LD_MODE1;
                sdramRegisterRAS = 0;
                sdramRegisterCAS = 0;
                sdramRegisterWE = 0;
                sdramRegisterCS = 0;
                sdramRegisterA[12:0] = mode_reg;

            case SD_LD_MODE1:
                sdramRegisterCS = 1;
                sdramRegisterRAS = 1;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;					// Load Mode takes 12nS
                sd_state = SD_IDLE;			// Add wait if needed

            // ** Auto refresh command ************************************
            case SD_AUTO_REF:
                sd_state = SD_AUTO_REF1;
                sdramRegisterRAS = 0;
                sdramRegisterCAS = 0;
                sdramRegisterWE = 1;
                sdramRegisterCS = 0;
                wait_count = REFRESH_WAIT;

            case SD_AUTO_REF1:
                sdramRegisterCS = 1;					// Issue NOP during wait
                sdramRegisterRAS = 1;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;
                if (wait_count[5]) {
                    // Time up, return to idle
                    sd_state = SD_AUTO_REF_ACK;
                    refreshAcknowledge = 1;
                }

            case SD_AUTO_REF_ACK:
                // Interlocking state
                sd_state = SD_IDLE;
                refreshAcknowledge = 0;

            // ** Read cycle **********************************************
            case SD_RD_START:
                sd_state = SD_RD_COL;
                sdramRegisterRAS = 0;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;
                sdramRegisterCS = 0;
                sdramRegisterBA[1:0] = busWordAddress[23:22];
                sdramRegisterA[12:0] = busWordAddress[21:9];
                wait_count = ACCESS_WAIT;
                ddrRegisterDataOutEnable = 0;						// Not driving the bus
                ddrRegisterDataStrobe = 0;

            case SD_RD_COL:
                if (~wait_count[5]) {
                    sdramRegisterCS = 1;			// NOP command during access wait
                    sdramRegisterRAS = 1;
                    sdramRegisterCAS = 1;
                    sdramRegisterWE = 1;
                } else {
                    sdramRegisterCS = 0;				// Access column
                    sdramRegisterRAS = 1;
                    sdramRegisterCAS = 0;
                    sdramRegisterWE = 1;
                    sd_state = SD_RD_CAS_WAIT;
                    sdramRegisterA[9:1] = busWordAddress[8:0];
                    sdramRegisterA[10] = 1;			// Use auto-precharge
                    sdramRegisterA[0] = 0;
                    wait_count = CAS_WAIT;
                    ddrRegisterDataStrobeEnable = 0;			// Set DQS for input
                }

            case SD_RD_CAS_WAIT:
                if (~wait_count[5]) {
                    sdramRegisterCS = 1;				// NOP command during access wait
                    sdramRegisterRAS = 1;
                    sdramRegisterCAS = 1;
                    sdramRegisterWE = 1;
                } else {
                    sd_state = SD_RD_LATCH;
                }

            case SD_RD_LATCH:
                busRegisterReadData = ddrRegisterDataIn;
                busRegisterAcknowledge = 1;
                sd_state = SD_RD_DONE;

            case SD_RD_DONE:
                busRegisterAcknowledge = 1;
                sd_state = SD_RD_DONE_1;
                ddrRegisterDataStrobe = 0;
                ddrRegisterDataStrobeEnable = 1;	// Set DQS back to output

            case SD_RD_DONE_1:
                busRegisterAcknowledge = 0;
                sd_state = SD_IDLE;

            // ** Write cycle *********************************************
            case SD_WR_START:
                sd_state = SD_WR_COL;
                sdramRegisterRAS = 0;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;
                sdramRegisterCS = 0;
                sdramRegisterBA[1:0] = busWordAddress[23:22];
                sdramRegisterA[12:0] = busWordAddress[21:9];
                ddrRegisterDataOut = busWriteData;
                ddrRegisterDataOutMask = ~busWriteMask;
                wait_count = ACCESS_WAIT;
                ddrRegisterDataStrobe = 0;

            case SD_WR_COL:
                if (~wait_count[5]) {
                    sdramRegisterCS = 1;			// NOP command during access wait
                    sdramRegisterRAS = 1;
                    sdramRegisterCAS = 1;
                    sdramRegisterWE = 1;
                } else {
                    sdramRegisterCS = 0;			// Access column
                    sdramRegisterRAS = 1;
                    sdramRegisterCAS = 0;
                    sdramRegisterWE = 0;
                    ddrRegisterDataStrobeEnable = 1;
                    sd_state = SD_WR_CAS_WAIT;
                    sdramRegisterA[9:1] = busWordAddress[8:0];
                    sdramRegisterA[10] = 1;		// Use auto-precharge
                    sdramRegisterA[0] = 0;
                }

            case SD_WR_CAS_WAIT:
                sd_state = SD_WR_LATCH;
                ddrRegisterDataStrobe = 1;			// Start with DQS low
                ddrRegisterDataOutEnable = 1;				// Drive the data bus
                sdramRegisterCS = 1;
                sdramRegisterRAS = 1;
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;

            case SD_WR_LATCH:
                sd_state = SD_WR_LATCH1;
                ddrRegisterDataStrobe = 0;

            case SD_WR_LATCH1:
                sd_state = SD_WR_DONE;
                ddrRegisterDataStrobe = 0;
                busRegisterAcknowledge = 1;

            case SD_WR_DONE:
                ddrRegisterDataOutEnable = 0;
                busRegisterAcknowledge = 1;
                sd_state = SD_WR_DONE_1;

            case SD_WR_DONE_1:
                busRegisterAcknowledge = 0;
                sd_state = SD_IDLE;

            // Wishbone transfer is done during idle time
            case SD_IDLE: 						// Idle/sleep process
                sdramRegisterRAS = 1;				// Set for NOP by default
                sdramRegisterCAS = 1;
                sdramRegisterWE = 1;
                sdramRegisterCS = 1;
                if (init_state != SI_DONE) {
                    sd_state = SD_INIT;
                } else if (busEnable & ~busWrite) {
                    sd_state = SD_RD_START;
                } else if (busEnable & busWrite) {
                    sd_state = SD_WR_START;
                } else if (refreshRequest) {
                    sd_state = SD_AUTO_REF;
                }

            default:
                sd_state = SD_IDLE;

        }
    }
}

// refresh control logic
register bit refreshRequest;
register vector[10] refreshCounter;
register vector[4] refreshQueue;

do (clk0) {
    if (refreshAcknowledge) {
        refreshRequest = 0;
        refreshQueue = refreshQueue + 4d1;
    } else if (reset) {
        refreshCounter = 0;
        refreshQueue = 0;
    } else {
        refreshCounter = refreshCounter + 10d1;
        if (refreshCounter == AVG_REFRESH_DUR) {
            refreshCounter = 0;
            if (refreshQueue != 4d0) {
                refreshQueue = refreshQueue - 4d1;
            }
        }
        if (refreshQueue != 4d7) {
            refreshRequest = 1;
        }
    }
}
