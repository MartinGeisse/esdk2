module name.martingeisse.esdk.riscv.rtl.Multicycle;

interface {

	// system signals
	in clock clk;
	in bit reset;

	// memory access interface
	out bit memoryEnable;
	out bit memoryWrite;
	out vector[30] memoryWordAddress;
	in vector[32] memoryReadData;
	out vector[32] memoryWriteData;
	out vector[4] memoryWriteMask;
	in bit memoryAcknowledge;

}

// --------------------------------------------------------------------------------------------------------------------
// definitions
// --------------------------------------------------------------------------------------------------------------------

// state machine
constant vector[5] STATE_START = 0;
constant vector[5] STATE_FETCH = 1;
constant vector[5] STATE_DECODE_AND_READ1 = 2;
constant vector[5] STATE_DECODE_AND_READ2 = 3;
constant vector[5] STATE_EXEC_OP_0 = 4;
constant vector[5] STATE_EXEC_OP_1 = 5;
constant vector[5] STATE_EXEC_OP_2 = 6;
constant vector[5] STATE_EXEC_OP_3 = 7;
constant vector[5] STATE_PREPARE_BRANCH = 8;
constant vector[5] STATE_EXEC_BRANCH = 9;
constant vector[5] STATE_EXEC_LUI = 10;
constant vector[5] STATE_EXEC_AUIPC = 11;
constant vector[5] STATE_EXEC_JAL = 12;
constant vector[5] STATE_EXEC_JALR = 13;
constant vector[5] STATE_MEM_COMPUTE_ADDRESS = 14;
constant vector[5] STATE_MEM_ACCESS = 15;
constant vector[5] STATE_MEM_EXTEND = 16;
constant vector[5] STATE_EXCEPTION = 17;
constant vector[5] STATE_SYSTEM_INSTRUCTION = 18;
constant vector[5] STATE_CSR_INSTRUCTION = 19;
constant vector[5] STATE_WRITE_MISC_VALUE_TO_REGISTER = 20;
constant vector[5] STATE_OMEGA_INSTRUCTION = 21;

// CPU state
register vector[5] state = STATE_START;
register vector[32] pc = 0;
register matrix[32][32] registers;
register vector[32] instructionRegister; // TODO consider prefixing module ports with (interface.)portName to avoid these ugly local names (but sucks for clk)
register vector[32] oldPc = 0;
register vector[32] registerReadValue; // register reads go here
register vector[32] firstRegisterValue; // first read value is stored here on second read
register vector[32] aluImmediate;
register vector[32] memoryAddressRegister;
register vector[32] memoryReadDataRegister;
register vector[32] miscRegisterWriteValue;

// omega-mode related state
register bit omegaMode = 0;
register vector[32] omegaReturnAddress;

// special registers including CSRs
constant vector[5] EXCEPTION_NONE = 0;
constant vector[5] EXCEPTION_INVALID_INSTRUCTION = 1;
register vector[5] exceptionCode = 0;

// --------------------------------------------------------------------------------------------------------------------
// derived signals
// --------------------------------------------------------------------------------------------------------------------

// decoding
signal vector[5] opcode = instructionRegister[6:2];
signal vector[5] sourceRegisterIndex1 = instructionRegister[19:15];
signal vector[5] sourceRegisterIndex2 = instructionRegister[24:20];
signal vector[5] destinationRegisterIndex = instructionRegister[11:7];
signal bit operationIsMulDev = (opcode[3] & instructionRegister[25]);

// execution helpers
signal vector[32] sourceValue1 = firstRegisterValue;
signal vector[32] sourceValue2 = opcode[3] ? registerReadValue : aluImmediate;
signal bit isLTS = (~sourceValue1[31] _ sourceValue1[30:0]) < (~sourceValue2[31] _ sourceValue2[30:0]);
signal bit isLTU = (sourceValue1 < sourceValue2);

// memory interface
do (*) {
	memoryEnable = (state == STATE_MEM_ACCESS) | (state == STATE_FETCH);
	memoryWrite = (state == STATE_MEM_ACCESS) & opcode[3];
	memoryWordAddress = memoryAddressRegister[31:2];
	if (instructionRegister[13]) {
		memoryWriteMask = 4b1111;
		memoryWriteData = registerReadValue;
	} else if (instructionRegister[12]) {
		memoryWriteMask = memoryAddressRegister[1] ? 4b1100 : 4b0011;
		memoryWriteData = registerReadValue[15:0] _ registerReadValue[15:0];
	} else {
		memoryWriteMask = memoryAddressRegister[1] ? (memoryAddressRegister[0] ? 4b1000 : 4b0100) : (memoryAddressRegister[0] ? 4b0010 : 4b0001);
		memoryWriteData = registerReadValue[7:0] _ registerReadValue[7:0] _ registerReadValue[7:0] _ registerReadValue[7:0];
	}
}

// --------------------------------------------------------------------------------------------------------------------
// ALU logic
// --------------------------------------------------------------------------------------------------------------------

// this register is loaded even before the first execution state, so it is ready when computing temporary results
register bit rightShiftInBit;

// state STATE_EXEC_OP_0 is used to perform this step
register vector[32] leftShiftPreparationResult;
register vector[32] multiplierPreparationResultLowLow;
register vector[32] multiplierPreparationResultLowHigh;
register vector[32] multiplierPreparationResultHighLow;
do (clk) {
	leftShiftPreparationResult = sourceValue1 << sourceValue2[2:0];
	multiplierPreparationResultLowLow = (16d0 _ firstRegisterValue[15:0]) * (16d0 _ registerReadValue[15:0]);
	multiplierPreparationResultLowHigh = (16d0 _ firstRegisterValue[15:0]) * (16d0 _ registerReadValue[31:16]);
	multiplierPreparationResultHighLow = (16d0 _ firstRegisterValue[31:16]) * (16d0 _ registerReadValue[15:0]);
}

// I am using a temporary result register for now. From/to constraints do not work well with Xilinx tools (one of the
// worst UIs I have ever seen...) and since the CPU should eventually be pipelined, an extra register will be needed
// anyway and will become a pipeline register at that point.
register vector[32] execOpTemporaryResultAddSub;
register vector[32] execOpTemporaryResultShiftLeft;
register bit execOpTemporaryResultLessThan;
register vector[32] execOpTemporaryResultShiftRight;
register vector[32] execOpTemporaryResultMul;
do(clk) {
	execOpTemporaryResultAddSub = (opcode[3] & instructionRegister[30]) ? (sourceValue1 - sourceValue2) : (sourceValue1 + sourceValue2);
	execOpTemporaryResultShiftLeft = sourceValue2[3] ? (leftShiftPreparationResult[23:0] _ repeat(8, bit(0))) : leftShiftPreparationResult;
	execOpTemporaryResultLessThan = (instructionRegister[12] ? isLTU : isLTS);
	execOpTemporaryResultShiftRight = ((repeat(16, rightShiftInBit) _ sourceValue1) >> sourceValue2[3:0])[31:0]; // SRA / SRL
	execOpTemporaryResultMul = multiplierPreparationResultLowLow + (multiplierPreparationResultLowHigh[15:0] _ 16d0) + (multiplierPreparationResultHighLow[15:0] _ 16d0);
}

register vector[32] execOpResult;
do (clk) {
	if (~operationIsMulDev) {
		execOpResult = switch(instructionRegister[14:12]) {
			case 3d0: execOpTemporaryResultAddSub // ADD / SUB
			case 3d1: sourceValue2[4] ? (execOpTemporaryResultShiftLeft[15:0] _ repeat(16, bit(0))) : execOpTemporaryResultShiftLeft // SLL
			case 3d2, 3d3: execOpTemporaryResultLessThan ? 32d1 : 32d0 // SLT, SLTU
			case 3d4: sourceValue1 ^ sourceValue2 // XOR
			case 3d5: sourceValue2[4] ? (repeat(16, rightShiftInBit) _ execOpTemporaryResultShiftRight[31:16]) : execOpTemporaryResultShiftRight // SRL, SRA
			case 3d6: sourceValue1 | sourceValue2 // OR
			case 3d7: sourceValue1 & sourceValue2 // AND
		};
	} else {
		execOpResult = execOpTemporaryResultMul;
	}
}

register bit partialBranchCondition;
do (clk) {
	partialBranchCondition = switch(instructionRegister[14:13]) {
		case 2d0: sourceValue1 == sourceValue2 // BEQ
		case 2d2: isLTS // BLT
		case 2d3: isLTU // BLTU
		default: bit(0)
	};
}

// --------------------------------------------------------------------------------------------------------------------
// zero/sign extension logic
// --------------------------------------------------------------------------------------------------------------------

// halfword-to-word extension
signal bit halfwordToWordSignBit = memoryAddressRegister[1] ? memoryReadDataRegister[31] : memoryReadDataRegister[15];
signal vector[16] halfwordToWordExtension = instructionRegister[14] ? 16d0 : repeat(16, halfwordToWordSignBit);
signal vector[16] halfwordToWordData = memoryAddressRegister[1] ? memoryReadDataRegister[31:16] : memoryReadDataRegister[15:0];

// byte-to-word extension
signal bit byteToWordSignBit = switch (memoryAddressRegister[1:0]) {
	case 2d0: memoryReadDataRegister[7]
	case 2d1: memoryReadDataRegister[15]
	case 2d2: memoryReadDataRegister[23]
	case 2d3: memoryReadDataRegister[31]
};
signal vector[24] byteToWordExtension = instructionRegister[14] ? 24d0 : repeat(24, byteToWordSignBit);
signal vector[8] byteToWordData = switch (memoryAddressRegister[1:0]) {
	case 2d0: memoryReadDataRegister[7:0]
	case 2d1: memoryReadDataRegister[15:8]
	case 2d2: memoryReadDataRegister[23:16]
	case 2d3: memoryReadDataRegister[31:24]
};

// --------------------------------------------------------------------------------------------------------------------
// state machine
// --------------------------------------------------------------------------------------------------------------------

do (clk) {
	if (reset) {
		state = STATE_START;
		pc = 0;
	} else {
		switch (state) {

			case STATE_START:
				memoryAddressRegister = pc;
				if (~omegaMode) {
					omegaReturnAddress = pc;
				}
				state = STATE_FETCH;

			case STATE_FETCH:
				if (memoryAcknowledge) {
					state = STATE_DECODE_AND_READ1;
					instructionRegister = memoryReadData;
				}

			case STATE_DECODE_AND_READ1:
				oldPc = pc;
				pc = pc + 32d4;
				aluImmediate = repeat(20, instructionRegister[31]) _ instructionRegister[31:20];
				state = STATE_DECODE_AND_READ2;

			case STATE_DECODE_AND_READ2:
				firstRegisterValue = registerReadValue;
				rightShiftInBit = (instructionRegister[30] ? registerReadValue[31] : bit(0));
				switch (opcode) {

					case 5d0: // LOAD
						state = STATE_MEM_COMPUTE_ADDRESS;

					case 5d2: // custom-0: omega-mode instructions
						if (omegaMode) {
							state = STATE_OMEGA_INSTRUCTION;
						} else {
							state = STATE_EXCEPTION;
							exceptionCode = EXCEPTION_INVALID_INSTRUCTION;
						}

					case 5d3: // MISC-MEM
						state = STATE_START;

					case 5d4: // OP-IMM
						state = (instructionRegister[14:12] == 3d1) ? STATE_EXEC_OP_0 : STATE_EXEC_OP_1;

					case 5d5: // AUIPC
						state = STATE_EXEC_AUIPC;

					case 5d8: // STORE
						state = STATE_MEM_COMPUTE_ADDRESS;

					case 5d12: // OP
						if (operationIsMulDev) {
							state = (instructionRegister[14:12] == 3d0) ? STATE_EXEC_OP_0 : STATE_EXEC_OP_1;
						} else {
							state = (instructionRegister[14:12] == 3d1) ? STATE_EXEC_OP_0 : STATE_EXEC_OP_1;
						}

					case 5d13: // LUI
						state = STATE_EXEC_LUI;

					case 5d24: // BRANCH
						state = STATE_PREPARE_BRANCH;

					case 5d25: // JALR
						state = STATE_EXEC_JALR;

					case 5d27: // JAL
						state = STATE_EXEC_JAL;

					case 5d28: // SYSTEM
						state = STATE_SYSTEM_INSTRUCTION;

					default: // includes MISC-MEM (=NOP) and SYSTEM
						state = STATE_EXCEPTION;
						exceptionCode = EXCEPTION_INVALID_INSTRUCTION;

				}

			case STATE_EXEC_OP_0:
				state = STATE_EXEC_OP_1;

			case STATE_EXEC_OP_1:
				if (operationIsMulDev & instructionRegister[14:12] != 3d0) {
					state = STATE_EXCEPTION;
					exceptionCode = EXCEPTION_INVALID_INSTRUCTION;
				} else {
					state = STATE_EXEC_OP_2;
				}

			case STATE_EXEC_OP_2:
				state = STATE_EXEC_OP_3;

			case STATE_EXEC_OP_3:
				state = STATE_START;

			case STATE_PREPARE_BRANCH:
				// this state loads partialBranchCondition
				state = STATE_EXEC_BRANCH;

			case STATE_EXEC_BRANCH:
				if (partialBranchCondition ^ instructionRegister[12]) {
					pc = oldPc + (repeat(20, instructionRegister[31]) _ instructionRegister[7] _ instructionRegister[30:25] _ instructionRegister[11:8] _ 1b0);
				}
				state = STATE_START;

			case STATE_EXEC_LUI:
				state = STATE_START;

			case STATE_EXEC_AUIPC:
				state = STATE_START;

			case STATE_EXEC_JAL:
				pc = oldPc + (repeat(12, instructionRegister[31]) _ instructionRegister[19:12] _ instructionRegister[20] _ instructionRegister[30:21] _ 1b0);
				state = STATE_START;

			case STATE_EXEC_JALR:
				pc = (firstRegisterValue + (repeat(20, instructionRegister[31]) _ instructionRegister[31:20]))[31:1] _ 1b0;
				state = STATE_START;

			case STATE_MEM_COMPUTE_ADDRESS:
				if (opcode[3]) {
					memoryAddressRegister = firstRegisterValue + (repeat(20, instructionRegister[31]) _ instructionRegister[31:25] _ instructionRegister[11:7]);
				} else {
					memoryAddressRegister = firstRegisterValue + aluImmediate;
				}
				state = STATE_MEM_ACCESS;

			case STATE_MEM_ACCESS:
				memoryReadDataRegister = memoryReadData;
				if (memoryAcknowledge) {
					state = opcode[3] ? STATE_START : STATE_MEM_EXTEND;
				}

			case STATE_MEM_EXTEND:
				state = STATE_START;

			case STATE_EXCEPTION:
				pc = 4;
				omegaMode = 1;
				state = STATE_START;

			case STATE_SYSTEM_INSTRUCTION:
				switch(instructionRegister[14:12]) {

					case 3b000, 3b100:
						state = STATE_EXCEPTION;
						exceptionCode = EXCEPTION_INVALID_INSTRUCTION;

					default:
						state = STATE_CSR_INSTRUCTION;

				}

			case STATE_CSR_INSTRUCTION:
				miscRegisterWriteValue = 32h11335577;
				state = STATE_WRITE_MISC_VALUE_TO_REGISTER;

			case STATE_WRITE_MISC_VALUE_TO_REGISTER:
				state = STATE_START;

			case STATE_OMEGA_INSTRUCTION:
				miscRegisterWriteValue = omegaReturnAddress;
				state = STATE_WRITE_MISC_VALUE_TO_REGISTER;

		}
	}
}

// register file BlockRAM support
signal vector[5] registersAddress = state == STATE_DECODE_AND_READ1 ? sourceRegisterIndex1 :
		(state == STATE_DECODE_AND_READ2 | state == STATE_EXEC_OP_0 | state == STATE_EXEC_OP_1 | state == STATE_EXEC_OP_2) ? sourceRegisterIndex2 : destinationRegisterIndex;
signal bit isRegisterWriteState = (state == STATE_EXEC_OP_3) | (state == STATE_EXEC_LUI) | (state == STATE_EXEC_AUIPC) |
		(state == STATE_EXEC_JAL) | (state == STATE_EXEC_JALR) | (state == STATE_MEM_EXTEND) | (state == STATE_WRITE_MISC_VALUE_TO_REGISTER);
signal vector[32] registerWriteValue = switch(state) {
	case STATE_EXEC_OP_3: execOpResult
	case STATE_EXEC_LUI: instructionRegister[31:12] _ 12d0
	case STATE_EXEC_AUIPC: oldPc + (instructionRegister[31:12] _ 12d0)
	case STATE_EXEC_JAL, STATE_EXEC_JALR: pc
	case STATE_MEM_EXTEND: instructionRegister[13] ? memoryReadDataRegister : instructionRegister[12] ?
			(halfwordToWordExtension _ halfwordToWordData) : (byteToWordExtension _ byteToWordData)
	default: miscRegisterWriteValue
};
do(clk) {
	if (state != STATE_MEM_COMPUTE_ADDRESS & state != STATE_MEM_ACCESS) {
		registerReadValue = registers[registersAddress];
		if (isRegisterWriteState & destinationRegisterIndex != 5d0) {
			registers[registersAddress] = registerWriteValue;
		}
	}
}
