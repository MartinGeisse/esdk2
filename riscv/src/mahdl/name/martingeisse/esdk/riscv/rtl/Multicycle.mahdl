module name.martingeisse.esdk.riscv.rtl.Multicycle;

interface {

	// system signals
	in clock clk;
	in bit reset;

	// memory access interface
	out bit memoryEnable;
	out bit memoryWrite;
	out vector[30] memoryWordAddress;
	in vector[32] memoryReadData;
	out vector[32] memoryWriteData;
	out vector[4] memoryWriteMask;
	in bit memoryAcknowledge;

}

// --------------------------------------------------------------------------------------------------------------------
// definitions
// --------------------------------------------------------------------------------------------------------------------

// state machine
constant vector[4] STATE_START = 0;
constant vector[4] STATE_FETCH = 1;
constant vector[4] STATE_DECODE_AND_READ1 = 2;
constant vector[4] STATE_DECODE_AND_READ2 = 3;
constant vector[4] STATE_EXEC_OP_1 = 4;
constant vector[4] STATE_EXEC_OP_2 = 5;
constant vector[4] STATE_PREPARE_BRANCH = 6;
constant vector[4] STATE_EXEC_BRANCH = 7;
constant vector[4] STATE_EXEC_LUI = 8;
constant vector[4] STATE_EXEC_AUIPC = 9;
constant vector[4] STATE_EXEC_JAL = 10;
constant vector[4] STATE_EXEC_JALR = 11;
constant vector[4] STATE_MEM_COMPUTE_ADDRESS = 12;
constant vector[4] STATE_MEM_ACCESS = 13;
constant vector[4] STATE_MEM_EXTEND = 14;

// CPU state
register vector[4] state = STATE_START;
register vector[32] pc = 0;
register matrix[32][32] registers;
register vector[32] instructionRegister; // TODO consider prefixing module ports with (interface.)portName to avoid these ugly local names (but sucks for clk)
register vector[32] oldPc = 0;
register vector[32] registerReadValue; // register reads go here
register vector[32] firstRegisterValue; // first read value is stored here on second read
register vector[32] aluImmediate;
register vector[32] memoryAddressRegister;
register vector[32] memoryReadDataRegister;

// --------------------------------------------------------------------------------------------------------------------
// derived signals
// --------------------------------------------------------------------------------------------------------------------

// decoding
signal vector[5] opcode = instructionRegister[6:2];
signal vector[5] sourceRegisterIndex1 = instructionRegister[19:15];
signal vector[5] sourceRegisterIndex2 = instructionRegister[24:20];
signal vector[5] destinationRegisterIndex = instructionRegister[11:7];

// execution helpers
signal vector[32] sourceValue1 = firstRegisterValue;
signal vector[32] sourceValue2 = opcode[3] ? registerReadValue : aluImmediate;
signal bit isLTS = (~sourceValue1[31] _ sourceValue1[30:0]) < (~sourceValue2[31] _ sourceValue2[30:0]);
signal bit isLTU = (sourceValue1 < sourceValue2);

// memory interface
do (*) {
	memoryEnable = (state == STATE_MEM_ACCESS) | (state == STATE_FETCH);
	memoryWrite = (state == STATE_MEM_ACCESS) & opcode[3];
	memoryWordAddress = memoryAddressRegister[31:2];
	if (instructionRegister[13]) {
		memoryWriteMask = 4b1111;
		memoryWriteData = registerReadValue;
	} else if (instructionRegister[12]) {
		memoryWriteMask = memoryAddressRegister[1] ? 4b1100 : 4b0011;
		memoryWriteData = registerReadValue[15:0] _ registerReadValue[15:0];
	} else {
		memoryWriteMask = memoryAddressRegister[1] ? (memoryAddressRegister[0] ? 4b1000 : 4b0100) : (memoryAddressRegister[0] ? 4b0010 : 4b0001);
		memoryWriteData = registerReadValue[7:0] _ registerReadValue[7:0] _ registerReadValue[7:0] _ registerReadValue[7:0];
	}
}

// --------------------------------------------------------------------------------------------------------------------
// ALU logic
// --------------------------------------------------------------------------------------------------------------------

// I am using a temporary result register for now. I might have used a from/to constraint to avoid extra registers
// (though I would still have to add an extra state to the state machine to make the contraint correct), but since
// the CPU should eventually be pipelined, an extra register will be needed anyway and will become a pipeline register
// at that point.

register vector[32] execOpTemporaryResultAddSub;
register vector[32] execOpTemporaryResultShiftLeft;
register bit execOpTemporaryResultLessThan;
register vector[32] execOpTemporaryResultShiftRight;
do(clk) {
	execOpTemporaryResultAddSub = (opcode[3] & instructionRegister[30]) ? (sourceValue1 - sourceValue2) : (sourceValue1 + sourceValue2);
	execOpTemporaryResultShiftLeft = sourceValue1 << sourceValue2[4:0];
	execOpTemporaryResultLessThan = (instructionRegister[12] ? isLTU : isLTS);
	execOpTemporaryResultShiftRight = instructionRegister[30] ?
			((repeat(32, sourceValue1[31]) _ sourceValue1) >> sourceValue2[4:0])[31:0] // SRA
			: (sourceValue1 >> sourceValue2[4:0]); // SRL
}

signal vector[32] execOpResult = switch(instructionRegister[14:12]) {
	case 3d0: execOpTemporaryResultAddSub // ADD / SUB
	case 3d1: execOpTemporaryResultShiftLeft // SLL
	case 3d2, 3d3: execOpTemporaryResultLessThan ? 32d1 : 32d0 // SLT, SLTU
	case 3d4: sourceValue1 ^ sourceValue2 // XOR
	case 3d5: execOpTemporaryResultShiftRight // SRL, SRA
	case 3d6: sourceValue1 | sourceValue2 // OR
	case 3d7: sourceValue1 & sourceValue2 // AND
};

register bit partialBranchCondition;
do (clk) {
	partialBranchCondition = switch(instructionRegister[14:13]) {
		case 2d0: sourceValue1 == sourceValue2 // BEQ
		case 2d2: isLTS // BLT
		case 2d3: isLTU // BLTU
		default: bit(0)
	};
}

// --------------------------------------------------------------------------------------------------------------------
// zero/sign extension logic
// --------------------------------------------------------------------------------------------------------------------

// halfword-to-word extension
signal bit halfwordToWordSignBit = memoryAddressRegister[1] ? memoryReadDataRegister[31] : memoryReadDataRegister[15];
signal vector[16] halfwordToWordExtension = instructionRegister[14] ? 16d0 : repeat(16, halfwordToWordSignBit);
signal vector[16] halfwordToWordData = memoryAddressRegister[1] ? memoryReadDataRegister[31:16] : memoryReadDataRegister[15:0];

// byte-to-word extension
signal bit byteToWordSignBit = switch (memoryAddressRegister[1:0]) {
	case 2d0: memoryReadDataRegister[7]
	case 2d1: memoryReadDataRegister[15]
	case 2d2: memoryReadDataRegister[23]
	case 2d3: memoryReadDataRegister[31]
};
signal vector[24] byteToWordExtension = instructionRegister[14] ? 24d0 : repeat(24, byteToWordSignBit);
signal vector[8] byteToWordData = switch (memoryAddressRegister[1:0]) {
	case 2d0: memoryReadDataRegister[7:0]
	case 2d1: memoryReadDataRegister[15:8]
	case 2d2: memoryReadDataRegister[23:16]
	case 2d3: memoryReadDataRegister[31:24]
};

// --------------------------------------------------------------------------------------------------------------------
// state machine
// --------------------------------------------------------------------------------------------------------------------

do (clk) {
	if (reset) {
		state = STATE_START;
		pc = 0;
	} else {
		switch (state) {

			case STATE_START:
				memoryAddressRegister = pc;
				state = STATE_FETCH;

			case STATE_FETCH:
				if (memoryAcknowledge) {
					state = STATE_DECODE_AND_READ1;
					instructionRegister = memoryReadData;
				}

			case STATE_DECODE_AND_READ1:
				oldPc = pc;
				pc = pc + 32d4;
				aluImmediate = repeat(20, instructionRegister[31]) _ instructionRegister[31:20];
				state = STATE_DECODE_AND_READ2;

			case STATE_DECODE_AND_READ2:
				firstRegisterValue = registerReadValue;
				switch (opcode) {

					case 5d0: // LOAD
						state = STATE_MEM_COMPUTE_ADDRESS;

					case 5d4: // OP-IMM
						state = STATE_EXEC_OP_1;

					case 5d5: // AUIPC
						state = STATE_EXEC_AUIPC;

					case 5d8: // STORE
						state = STATE_MEM_COMPUTE_ADDRESS;

					case 5d12: // OP
						state = STATE_EXEC_OP_1;

					case 5d13: // LUI
						state = STATE_EXEC_LUI;

					case 5d24: // BRANCH
						state = STATE_PREPARE_BRANCH;

					case 5d25: // JALR
						state = STATE_EXEC_JALR;

					case 5d27: // JAL
						state = STATE_EXEC_JAL;

					default: // includes MISC-MEM (=NOP) and SYSTEM
						state = STATE_START;

				}

			case STATE_EXEC_OP_1:
				state = STATE_EXEC_OP_2;

			case STATE_EXEC_OP_2:
				state = STATE_START;

			case STATE_PREPARE_BRANCH:
				// this state loads partialBranchCondition
				state = STATE_EXEC_BRANCH;

			case STATE_EXEC_BRANCH:
				if (partialBranchCondition ^ instructionRegister[12]) {
					pc = oldPc + (repeat(20, instructionRegister[31]) _ instructionRegister[7] _ instructionRegister[30:25] _ instructionRegister[11:8] _ 1b0);
				}
				state = STATE_START;

			case STATE_EXEC_LUI:
				state = STATE_START;

			case STATE_EXEC_AUIPC:
				state = STATE_START;

			case STATE_EXEC_JAL:
				pc = oldPc + (repeat(12, instructionRegister[31]) _ instructionRegister[19:12] _ instructionRegister[20] _ instructionRegister[30:21] _ 1b0);
				state = STATE_START;

			case STATE_EXEC_JALR:
				pc = (firstRegisterValue + (repeat(20, instructionRegister[31]) _ instructionRegister[31:20]))[31:1] _ 1b0;
				state = STATE_START;

			case STATE_MEM_COMPUTE_ADDRESS:
				if (opcode[3]) {
					memoryAddressRegister = firstRegisterValue + (repeat(20, instructionRegister[31]) _ instructionRegister[31:25] _ instructionRegister[11:7]);
				} else {
					memoryAddressRegister = firstRegisterValue + aluImmediate;
				}
				state = STATE_MEM_ACCESS;

			case STATE_MEM_ACCESS:
				memoryReadDataRegister = memoryReadData;
				if (memoryAcknowledge) {
					state = opcode[3] ? STATE_START : STATE_MEM_EXTEND;
				}

			case STATE_MEM_EXTEND:
				state = STATE_START;

		}
	}
}

// register file BlockRAM support
signal vector[5] registersAddress = state == STATE_DECODE_AND_READ1 ? sourceRegisterIndex1 :
		(state == STATE_DECODE_AND_READ2 | state == STATE_EXEC_OP_1) ? sourceRegisterIndex2 : destinationRegisterIndex;
signal bit isRegisterWriteState = (state == STATE_EXEC_OP_2) | (state == STATE_EXEC_LUI) | (state == STATE_EXEC_AUIPC) |
		(state == STATE_EXEC_JAL) | (state == STATE_EXEC_JALR) | (state == STATE_MEM_EXTEND);
signal vector[32] registerWriteValue = switch(state) {
	case STATE_EXEC_OP_2: execOpResult
	case STATE_EXEC_LUI: instructionRegister[31:12] _ 12d0
	case STATE_EXEC_AUIPC: oldPc + (instructionRegister[31:12] _ 12d0)
	case STATE_EXEC_JAL, STATE_EXEC_JALR: pc
	case STATE_MEM_EXTEND: instructionRegister[13] ? memoryReadDataRegister : instructionRegister[12] ?
			(halfwordToWordExtension _ halfwordToWordData) : (byteToWordExtension _ byteToWordData)
	default: 32d0
};
do(clk) {
	if (state != STATE_MEM_COMPUTE_ADDRESS & state != STATE_MEM_ACCESS) {
		registerReadValue = registers[registersAddress];
		if (isRegisterWriteState & destinationRegisterIndex != 5d0) {
			registers[registersAddress] = registerWriteValue;
		}
	}
}
