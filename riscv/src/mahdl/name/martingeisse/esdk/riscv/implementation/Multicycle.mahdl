module name.martingeisse.esdk.riscv.implementation.Multicycle;

interface {

	// system signals
	in clock clk;

	// instruction fetching interface
	out vector[30] instructionWordAddress;
	out bit instructionReadEnable;
	in vector[32] instruction;
	in bit instructionReadAcknowledge;

	// memory access interface
	out bit memoryEnable;
	out bit memoryWrite;
	out vector[30] memoryWordAddress;
	in vector[32] memoryReadData;
	out vector[32] memoryWriteData;
	out vector[4] memoryWriteMask;
	in bit memoryAcknowledge;

}

// --------------------------------------------------------------------------------------------------------------------
// definitions
// --------------------------------------------------------------------------------------------------------------------

// state machine
constant vector[4] STATE_FETCH = 0;
constant vector[4] STATE_DECODE_AND_READ1 = 1;
constant vector[4] STATE_DECODE_AND_READ2 = 2;
constant vector[4] STATE_EXEC_OP = 3;
constant vector[4] STATE_EXEC_BRANCH = 4;
constant vector[4] STATE_EXEC_LUI = 5;
constant vector[4] STATE_EXEC_AUIPC = 6;
constant vector[4] STATE_EXEC_JAL = 7;
constant vector[4] STATE_EXEC_JALR = 8;
constant vector[4] STATE_MEM_COMPUTE_ADDRESS = 9;
constant vector[4] STATE_MEM_ACCESS = 10;
constant vector[4] STATE_MEM_EXTEND = 11;

// CPU state
register vector[4] state = STATE_FETCH;
register vector[32] pc = 0;
register matrix[32][32] registers;
register vector[32] instructionRegister; // TODO consider prefixing module ports with (interface.)portName to avoid these ugly local names (but sucks for clk)
register vector[32] oldPc = 0;
register vector[32] sourceValue1;
register vector[32] sourceValue2;
register vector[32] memoryAddressRegister;
register vector[32] memoryReadDataRegister;

// --------------------------------------------------------------------------------------------------------------------
// derived signals
// --------------------------------------------------------------------------------------------------------------------

// instruction fetching
do (*) {
	instructionReadEnable = (state == STATE_FETCH);
	instructionWordAddress = pc[31:2];
}

// decoding
signal vector[5] opcode = instructionRegister[6:2];
signal vector[5] sourceRegisterIndex1 = instructionRegister[19:15];
signal vector[5] sourceRegisterIndex2 = instructionRegister[24:20];
signal vector[5] destinationRegisterIndex = instructionRegister[11:7];

// execution helpers
signal bit isLTS = (~sourceValue1[31] _ sourceValue1[30:0]) < (~sourceValue2[31] _ sourceValue2[30:0]);
signal bit isLTU = (sourceValue1 < sourceValue2);

// memory interface
do (*) {
	memoryEnable = (state == STATE_MEM_ACCESS);
	memoryWrite = opcode[3];
	memoryWordAddress = memoryAddressRegister[31:2];
	memoryWriteData = sourceValue2;
	memoryWriteMask = instruction[13] ? 4b1111 : instruction[12] ? (memoryAddressRegister[1] ? 4b1100 : 4b0011) : 4d0; // TODO
}

// --------------------------------------------------------------------------------------------------------------------
// logic taken out of the state machine to make it clearer
// --------------------------------------------------------------------------------------------------------------------

signal vector[32] execOpResult = switch(instructionRegister[14:12]) {
    case 3d0: sourceValue1 + sourceValue2 // ADD
    case 3d1: sourceValue1 << sourceValue2[4:0] // SLL
    case 3d2: isLTS ? 32d1 : 32d0 // SLT
    case 3d3: isLTU ? 32d1 : 32d0 // SLTU
    case 3d4: sourceValue1 ^ sourceValue2 // XOR
    case 3d5: instructionRegister[30] ?
			((repeat(32, sourceValue1[31]) _ sourceValue1) >> sourceValue2[4:0])[31:0] // SRA
            : (sourceValue1 >> sourceValue2[4:0]) // SRL
    case 3d6: sourceValue1 | sourceValue2 // OR
    case 3d7: sourceValue1 & sourceValue2 // AND
};

signal bit branchCondition = switch(instructionRegister[14:12]) {
    case 3d0: sourceValue1 == sourceValue2 // BEQ
    case 3d1: sourceValue1 != sourceValue2 // BNE
    case 3d4: isLTS // BLT
    case 3d5: ~isLTS // BGE
    case 3d6: isLTU // BLTU
    case 3d7: ~isLTU // BGEU
    default: bit(0)
};

// --------------------------------------------------------------------------------------------------------------------
// state machine
// --------------------------------------------------------------------------------------------------------------------

do (clk) {
	switch (state) {

		case STATE_FETCH:
			if (instructionReadAcknowledge) {
				state = STATE_DECODE_AND_READ1;
				instructionRegister = instruction;
			}

		case STATE_DECODE_AND_READ1:
			oldPc = pc;
			pc = pc + 32d4;
			sourceValue1 = registers[sourceRegisterIndex1];
			sourceValue2 = repeat(20, instructionRegister[31]) _ instructionRegister[31:20];
			switch (opcode) {

				case 5d0: // LOAD
					state = STATE_MEM_COMPUTE_ADDRESS;

				case 5d4: // OP-IMM
					state = STATE_EXEC_OP;

				case 5d5: // AUIPC
					state = STATE_EXEC_AUIPC;

				case 5d8: // STORE
					state = STATE_MEM_COMPUTE_ADDRESS;

				case 5d12: // OP
					state = STATE_DECODE_AND_READ2;

				case 5d13: // LUI
					state = STATE_EXEC_LUI;

				case 5d24: // BRANCH
					state = STATE_DECODE_AND_READ2;

				case 5d25: // JALR
					state = STATE_EXEC_JALR;

				case 5d27: // JAL
					state = STATE_EXEC_JAL;

				default: // includes MISC-MEM (=NOP) and SYSTEM
					state = STATE_FETCH;

			}

		case STATE_DECODE_AND_READ2:
			sourceValue2 = registers[sourceRegisterIndex2];
			state = (opcode[4] ? STATE_EXEC_BRANCH : STATE_EXEC_OP);

		case STATE_EXEC_OP:
			if (destinationRegisterIndex != 5d0) {
            	registers[destinationRegisterIndex] = execOpResult;
			}
			state = STATE_FETCH;

		case STATE_EXEC_BRANCH:
			if (branchCondition) {
				pc = oldPc + (repeat(20, instructionRegister[31]) _ instructionRegister[7] _ instructionRegister[30:25] _ instructionRegister[11:8] _ 1b0);
			}
			state = STATE_FETCH;

		case STATE_EXEC_LUI:
			if (destinationRegisterIndex != 5d0) {
				registers[destinationRegisterIndex] = instructionRegister[31:12] _ 12d0;
			}
			state = STATE_FETCH;

		case STATE_EXEC_AUIPC:
			if (destinationRegisterIndex != 5d0) {
				registers[destinationRegisterIndex] = oldPc + (instructionRegister[31:12] _ 12d0);
			}
			state = STATE_FETCH;

		case STATE_EXEC_JAL:
			if (destinationRegisterIndex != 5d0) {
				registers[destinationRegisterIndex] = pc;
			}
			pc = oldPc + (repeat(12, instructionRegister[31]) _ instructionRegister[19:12] _ instructionRegister[20] _ instructionRegister[30:21] _ 1b0);
			state = STATE_FETCH;

		case STATE_EXEC_JALR:
			if (destinationRegisterIndex != 5d0) {
				registers[destinationRegisterIndex] = pc;
			}
			pc = (sourceValue1 + (repeat(20, instructionRegister[31]) _ instructionRegister[31:20]))[31:1] _ 1b0;
			state = STATE_FETCH;

		case STATE_MEM_COMPUTE_ADDRESS:
			if (opcode[3]) {
				memoryAddressRegister = sourceValue1 + (repeat(20, instructionRegister[31]) _ instructionRegister[31:25] _ instructionRegister[11:7]);
			} else {
				memoryAddressRegister = sourceValue1 + sourceValue2;
			}
			sourceValue2 = registers[sourceRegisterIndex2]; // TODO halfword / byte shifting
			state = STATE_MEM_ACCESS;

		case STATE_MEM_ACCESS:
			memoryReadDataRegister = memoryReadData;
			if (memoryAcknowledge) {
				state = opcode[3] ? STATE_FETCH : STATE_MEM_EXTEND;
			}

		case STATE_MEM_EXTEND:
			if (destinationRegisterIndex != 5d0) {
				registers[destinationRegisterIndex] = memoryReadDataRegister;
			}
			// TODO halfword / byte shifting
			// TODO zero/sign extension
			state = STATE_FETCH;

	}
}
