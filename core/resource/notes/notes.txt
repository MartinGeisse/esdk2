




bus.write(context, address, data);



bus:
getSlave(address & upper).write(context, address & lower, data);


-->
relationships müssen manuell gepflegt werden, aber das ist im highlevel model auch so
es müssen keine event nodes und keine listener gebaut werden. der aufruf eines listeners passiert direkt
asynchrone loops führen zu endlosrekursion --> an sich gut, das fällt sofort auf
ein zeitverzögerter event führt zum einhängen eines Runnable für später
wenn man das einhängen eines event-callbacks vergisst, dann passiert der effekt synchron-sofort

"simplest thing"! Wenn o.g. so funktioniert, dann wäre das super-einfach.

Was immer noch nötig ist, ist das erzeugen eines Simulationsmodells aus dem highlevel-modell, denn nur das
sim model hat laufzeit-zustand. Probleme damit:

- relationships müssen diese transformation überleben
	Transformierte Objekte in einer Map speichern, dessen key ist:
		class Key<UntransformiertesHighlevelObject, TransformiertesInterface>
	(beides sind Typparameter, extends Object) und der value ist ein TransformiertesInterface.

- evtl macht es sinn, an dieser stelle den context schon zu injecten, damit man ihn später nicht überall mitschleifen muss
	- aber dann ist es einfach nur die transformation, die ihn stattdessen mitschleifen muss
		- ja, aber die ist vermutlich weniger komplex --> beides ausprobieren!


------------------------------------------------------------------------------------------------------------------------

Die Alternative ist, dass die Highlevel-Objekte direkt simulierbar sind, was sehr viel Komplexität aus der Trafo
herausnehmen würde. Die synth-Trafo wäre noch die gleiche, aber dort gibt es nur eine kleine Menge von Zielobjekten,
d.h. die entsprechenden Interfaces müssten nicht generisch sein. Unschön wäre es vor allem deshalb, weil
Model-Eigenschaften mit Runtime-State vermischt werden und nur noch durch Dokumentation getrennt werden können.

Noch eine Alternative ist es, die Trafo zu vereinfachen, indem es keine Keys mehr gibt -- Objekte werden 1:1 abgebildet.
Der Fall mit mehreren Keys muss dann durch mehrere Sub-Objekte abgebildet werden. Das wäre zumindest nicht allzu
schlimm.

------------------------------------------------------------------------------------------------------------------------

Weitere Überlegung dazu:

- Vermischung von Model-Eigenschaften und Runtime State ist weniger schlimm als gedacht: Das Model kann erkennen,
	wenn nicht synthetisierbarer Runtime State vorhanden ist, und dann z.B. eine Exception werfen, oder noch besser,
	bei der Trafo dies als Fehler reporten, der gezielt in einzelnen Fällen von außen ignoriert werden kann.

- die Komplexität in der Synth-Trafo ist schlimmer als gedacht, wenn die Synth mehrstufig abläuft. Das ist vor allem
	zur Vermeidung der "Wasserfall-Nachteile" wichtig -- der Wasserfall darf nicht "ablaufen", sondern die gesamte
	"Wasserfall-Timeline" muss gleichzeitig im Programm modelliert werden, damit man schnell und flexibel alte
	Entscheidungen umstoßen kann.

	Ist das realistisch? Beispiel: System -> Komponenten -> CPU und Peripherie -> RTL

	... unklar. Schon der Schritt "Komponenten -> CPU und Peripherie" kann vermutlich nicht wirklich
	konfiguriert-automatisch ablaufen, sondern man baut CPU+Komponenten als zweites, paralleles Modell neu. Damit
	ist auch keine Trafo mit komplexen Output-Modell nötig -- die einzige Trafo ist die nach RTL, was ein sehr einfaches
	Modell ist (wenige Knotentypen).


