
All the 32-bit instructions in the base ISA have their lowest two bits set to 11

base + 0: xxxxxxxxxxxbbb11 (bbb != 111)
base + 2: xxxxxxxxxxxxxxxx

We consider it a feature that any length of instruction containing all zero bits is not legal, as this quickly traps
erroneous jumps into zeroed memory regions. Similarly, we also reserve the instruction encoding containing all ones
to be an illegal instruction, to catch the other common pattern observed with unprogrammed non-volatile memory
devices, disconnected memory buses, or broken memory devices.

We use the term exception to refer to an unusual condition occurring at run time associated with an instruction in the
current RISC-V thread. We use the term trap to refer to the synchronous transfer of control to a trap handler caused
by an exceptional condition occurring within a RISC-V thread. Trap handlers usually execute in a more privileged
environment.

We use the term interrupt to refer to an external event that occurs asynchronously to the current RISC-V thread. When
an interrupt that must be serviced occurs, some instruction is selected to receive an interrupt exception and
subsequently experiences a trap.

The instruction descriptions in following chapters describe conditions that raise an exception dur- ing execution.
Whether and how these are converted into traps is dependent on the execution environment, though the expectation is
that most environments will take a precise trap when an exception is signaled (except for floating-point exceptions,
which, in the standard floating-point extensions, do not cause traps).

... though a simple implementation might cover the eight SCALL/SBREAK/CSRR* instructions with a single SYSTEM hardware
instruction that always traps and might be able to implement the FENCE and FENCE.I in- structions as NOPs, reducing
hardware instruction count to 38 total. RV32I can emulate almost any other ISA extension (except the A extension,
which requires additional hardware support for atomicity).

There is no hardwired subroutine return address link register, but the standard software calling convention uses
register x1 to hold the return address on a call.

XLEN = 32

Registers: zero, 31 x general purpose, pc

the program counter pc holds the address of the current instruction.

v1: FENCE = NOP

The FENCE.I instruction is used to synchronize the instruction and data streams. RISC-V does not guarantee that stores
to instruction memory will be made visible to instruction fetches on the same RISC-V hart until a FENCE.I instruction
is executed. A FENCE.I instruction only ensures that a subsequent instruction fetch on a RISC-V hart will see any
previous data stores already visible to the same RISC-V hart. FENCE.I does not ensure that other RISC-V harts’
instruction fetches will observe the local hart’s stores in a multiprocessor system. To make a store to instruction
memory visible to all RISC-V harts, the writing hart has to execute a data FENCE before requesting that all remote
RISC-V harts execute a FENCE.I.

v1: FENCE.I = NOP

CSR = control / status register

CSR*, ECALL, EBREAK -> single SYSTEM instruction + software emu (?)
    usermode sim: subclass decides
    system sim: default impl transfers control to trap handler

We define the full set of CSR instructions here, although in the standard user-level base ISA, only a handful of
read-only counter CSRs are accessible.

Implement division (possibly even multiplication) in software instruction emulation in v1.

